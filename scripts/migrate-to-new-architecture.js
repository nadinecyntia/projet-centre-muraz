const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
    user: process.env.DB_USER || 'postgres',
    host: process.env.DB_HOST || 'localhost',
    database: process.env.DB_NAME || 'centre_muraz',
    password: process.env.DB_PASSWORD || 'password',
    port: process.env.DB_PORT || 5432,
});

async function migrateToNewArchitecture() {
    try {
        console.log('üöÄ D√©but de la migration vers la nouvelle architecture...');
        
        // √âtape 1: Sauvegarder les donn√©es existantes
        console.log('üìã √âtape 1: Sauvegarde des donn√©es existantes...');
        await backupExistingData();
        
        // √âtape 2: Supprimer les anciennes tables
        console.log('üóëÔ∏è √âtape 2: Suppression des anciennes tables...');
        await dropOldTables();
        
        // √âtape 3: Cr√©er les nouvelles tables
        console.log('üèóÔ∏è √âtape 3: Cr√©ation des nouvelles tables...');
        await createNewTables();
        
        // √âtape 4: Cr√©er les index et contraintes
        console.log('üîç √âtape 4: Cr√©ation des index et contraintes...');
        await createIndexesAndConstraints();
        
        // √âtape 5: Restaurer les donn√©es (si possible)
        console.log('üì• √âtape 5: Restauration des donn√©es...');
        await restoreData();
        
        console.log('‚úÖ Migration termin√©e avec succ√®s !');
        
    } catch (error) {
        console.error('‚ùå Erreur lors de la migration:', error);
        throw error;
    } finally {
        await pool.end();
    }
}

async function backupExistingData() {
    try {
        // V√©rifier si la table biologie_moleculaire existe
        const checkTable = await pool.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'biologie_moleculaire'
            );
        `);
        
        if (checkTable.rows[0].exists) {
            console.log('üìä Sauvegarde de la table biologie_moleculaire...');
            
            // Cr√©er une table de sauvegarde
            await pool.query(`
                CREATE TABLE IF NOT EXISTS biologie_moleculaire_backup AS 
                SELECT * FROM biologie_moleculaire;
            `);
            
            const backupCount = await pool.query('SELECT COUNT(*) FROM biologie_moleculaire_backup');
            console.log(`‚úÖ ${backupCount.rows[0].count} enregistrements sauvegard√©s`);
        } else {
            console.log('‚ÑπÔ∏è Aucune table biologie_moleculaire √† sauvegarder');
        }
        
    } catch (error) {
        console.error('‚ö†Ô∏è Erreur lors de la sauvegarde:', error);
        // Continuer m√™me si la sauvegarde √©choue
    }
}

async function dropOldTables() {
    try {
        // Supprimer les anciennes tables dans l'ordre (d√©pendances)
        const tablesToDrop = [
            'analyses_pcr',
            'analyses_bioessai', 
            'analyses_repas_sanguin',
            'infos_communes',
            'biologie_moleculaire',
            'molecular_biology'
        ];
        
        for (const table of tablesToDrop) {
            try {
                await pool.query(`DROP TABLE IF EXISTS ${table} CASCADE;`);
                console.log(`üóëÔ∏è Table ${table} supprim√©e`);
            } catch (error) {
                console.log(`‚ÑπÔ∏è Table ${table} n'existait pas ou d√©j√† supprim√©e`);
            }
        }
        
    } catch (error) {
        console.error('‚ùå Erreur lors de la suppression des tables:', error);
        throw error;
    }
}

async function createNewTables() {
    try {
        // 1. Table principale des informations communes
        console.log('üèóÔ∏è Cr√©ation de la table infos_communes...');
        await pool.query(`
            CREATE TABLE infos_communes (
                id SERIAL PRIMARY KEY,
                
                -- Informations communes √† toutes les analyses
                analysis_type VARCHAR(50) NOT NULL, -- PCR, RT-PCR, Bioessai, Origine Repas Sanguin
                sample_stage VARCHAR(50) NOT NULL, -- ≈ìufs, larves, moustiques
                genus TEXT[] NOT NULL, -- Array pour s√©lection multiple [aedes, anopheles, culex, indetermine]
                species VARCHAR(100) NOT NULL,
                sector VARCHAR(50) NOT NULL, -- secteur_6, secteur_9, secteur_26, secteur_33
                sample_count INTEGER NOT NULL,
                collection_date DATE NOT NULL,
                analysis_date DATE NOT NULL,
                complementary_info TEXT,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
        `);
        
        // 2. Table des analyses PCR et RT-PCR
        console.log('üß¨ Cr√©ation de la table analyses_pcr...');
        await pool.query(`
            CREATE TABLE analyses_pcr (
                id SERIAL PRIMARY KEY,
                infos_communes_id INTEGER NOT NULL REFERENCES infos_communes(id) ON DELETE CASCADE,
                
                -- Champs sp√©cifiques PCR/RT-PCR
                identified_species TEXT[] NOT NULL, -- Array pour s√©lection multiple
                virus_types TEXT[] NOT NULL, -- Array pour s√©lection multiple [dengue, chikungunya, zika, fievre_jaune]
                homozygous_count INTEGER NOT NULL, -- Nombre d'individus homozygotes pour l'all√®le A
                heterozygous_count INTEGER NOT NULL, -- Nombre d'individus h√©t√©rozygotes
                total_population INTEGER NOT NULL, -- Nombre total d'individus dans la population
                allelic_frequency_a DECIMAL(5,4), -- Calcul√© automatiquement f(A)
                allelic_frequency_a_prime DECIMAL(5,4), -- Calcul√© automatiquement f(A')
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
        `);
        
        // 3. Table des analyses Bioessai
        console.log('üêõ Cr√©ation de la table analyses_bioessai...');
        await pool.query(`
            CREATE TABLE analyses_bioessai (
                id SERIAL PRIMARY KEY,
                infos_communes_id INTEGER NOT NULL REFERENCES infos_communes(id) ON DELETE CASCADE,
                
                -- Champs sp√©cifiques Bioessai
                insecticide_types TEXT[] NOT NULL, -- Array pour s√©lection multiple
                mortality_percentage DECIMAL(5,2) NOT NULL,
                survival_percentage DECIMAL(5,2) NOT NULL,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
        `);
        
        // 4. Table des analyses Origine Repas Sanguin
        console.log('ü©∏ Cr√©ation de la table analyses_repas_sanguin...');
        await pool.query(`
            CREATE TABLE analyses_repas_sanguin (
                id SERIAL PRIMARY KEY,
                infos_communes_id INTEGER NOT NULL REFERENCES infos_communes(id) ON DELETE CASCADE,
                
                -- Champs sp√©cifiques Origine Repas Sanguin
                blood_meal_origins TEXT[] NOT NULL, -- Array pour s√©lection multiple [homme, poule, b≈ìuf, porc, chien, √¢ne, mouton, ch√®vre]
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
        `);
        
        console.log('‚úÖ Toutes les nouvelles tables ont √©t√© cr√©√©es !');
        
    } catch (error) {
        console.error('‚ùå Erreur lors de la cr√©ation des tables:', error);
        throw error;
    }
}

async function createIndexesAndConstraints() {
    try {
        console.log('üîç Cr√©ation des index pour optimiser les performances...');
        
        // Index sur infos_communes
        await pool.query('CREATE INDEX IF NOT EXISTS idx_infos_communes_analysis_type ON infos_communes(analysis_type);');
        await pool.query('CREATE INDEX IF NOT EXISTS idx_infos_communes_sector ON infos_communes(sector);');
        await pool.query('CREATE INDEX IF NOT EXISTS idx_infos_communes_date ON infos_communes(analysis_date);');
        await pool.query('CREATE INDEX IF NOT EXISTS idx_infos_communes_genus ON infos_communes USING GIN(genus);');
        
        // Index sur analyses_pcr
        await pool.query('CREATE INDEX IF NOT EXISTS idx_analyses_pcr_infos_id ON analyses_pcr(infos_communes_id);');
        await pool.query('CREATE INDEX IF NOT EXISTS idx_analyses_pcr_virus ON analyses_pcr USING GIN(virus_types);');
        await pool.query('CREATE INDEX IF NOT EXISTS idx_analyses_pcr_species ON analyses_pcr USING GIN(identified_species);');
        
        // Index sur analyses_bioessai
        await pool.query('CREATE INDEX IF NOT EXISTS idx_analyses_bioessai_infos_id ON analyses_bioessai(infos_communes_id);');
        await pool.query('CREATE INDEX IF NOT EXISTS idx_analyses_bioessai_insecticide ON analyses_bioessai USING GIN(insecticide_types);');
        
        // Index sur analyses_repas_sanguin
        await pool.query('CREATE INDEX IF NOT EXISTS idx_analyses_repas_infos_id ON analyses_repas_sanguin(infos_communes_id);');
        await pool.query('CREATE INDEX IF NOT EXISTS idx_analyses_repas_origins ON analyses_repas_sanguin USING GIN(blood_meal_origins);');
        
        console.log('‚úÖ Tous les index ont √©t√© cr√©√©s !');
        
    } catch (error) {
        console.error('‚ùå Erreur lors de la cr√©ation des index:', error);
        throw error;
    }
}

async function restoreData() {
    try {
        // V√©rifier si des donn√©es de sauvegarde existent
        const checkBackup = await pool.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'biologie_moleculaire_backup'
            );
        `);
        
        if (checkBackup.rows[0].exists) {
            console.log('üì• Tentative de restauration des donn√©es...');
            
            // Pour l'instant, on ne restaure pas automatiquement
            // car la structure a compl√®tement chang√©
            console.log('‚ÑπÔ∏è Les donn√©es de sauvegarde sont conserv√©es dans biologie_moleculaire_backup');
            console.log('‚ÑπÔ∏è Une restauration manuelle sera n√©cessaire si besoin');
            
        } else {
            console.log('‚ÑπÔ∏è Aucune donn√©e √† restaurer');
        }
        
    } catch (error) {
        console.error('‚ö†Ô∏è Erreur lors de la restauration:', error);
    }
}

// Fonction utilitaire pour tester la nouvelle structure
async function testNewStructure() {
    try {
        console.log('\nüß™ Test de la nouvelle structure...');
        
        // V√©rifier que toutes les tables existent
        const tables = ['infos_communes', 'analyses_pcr', 'analyses_bioessai', 'analyses_repas_sanguin'];
        
        for (const table of tables) {
            const result = await pool.query(`
                SELECT COUNT(*) as count FROM ${table};
            `);
            console.log(`‚úÖ Table ${table}: ${result.rows[0].count} enregistrements`);
        }
        
        console.log('\nüéâ Structure test√©e avec succ√®s !');
        
    } catch (error) {
        console.error('‚ùå Erreur lors du test:', error);
    }
}

// Ex√©cuter la migration
if (require.main === module) {
    migrateToNewArchitecture()
        .then(() => {
            console.log('\nüöÄ Migration termin√©e !');
            console.log('\nüìã Prochaines √©tapes:');
            console.log('1. Modifier l\'API backend pour utiliser les nouvelles tables');
            console.log('2. Adapter la page d\'affichage pour les requ√™tes JOIN');
            console.log('3. Tester les nouveaux formulaires');
        })
        .catch((error) => {
            console.error('\nüí• Migration √©chou√©e:', error);
            process.exit(1);
        });
}

module.exports = {
    migrateToNewArchitecture,
    testNewStructure
};

